import sqlite3
from flask import Flask, request, jsonify, g
from datetime import datetime
import uuid
import os
import json
from flask_cors import CORS # New Import for CORS

# --- Configuration ---
DATABASE = 'hive_data.db'
# Using port 5001 to avoid conflicts with the default 5000
PORT_NUMBER = 5001

# --- Flask App Initialization ---
app = Flask(__name__)
# Initialize CORS to allow all origins ('*') for all routes, fixing the issue.
CORS(app)

# --- Database Connection and Setup ---

def get_db_connection():
    """Establishes a connection to the SQLite database."""
    # 'g' is an object provided by Flask to store and share data during a request
    if 'db' not in g:
        g.db = sqlite3.connect(
            DATABASE,
            detect_types=sqlite3.PARSE_DECLTYPES
        )
        # Allows accessing columns by name instead of index
        g.db.row_factory = sqlite3.Row
    return g.db

@app.teardown_appcontext
def close_connection(exception):
    """Closes the database connection at the end of the request."""
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    """Initializes the database by creating the 'hives' and 'hive_data' tables."""
    # Use a temporary connection just for setup
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()

    # Create the hives table
    # 'id' is generated by Python (UUID)
    # 'name' is mandatory and must be UNIQUE
    # 'creation_datetime' is managed by Python (ISO format)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS hives (
            id TEXT PRIMARY KEY,
            name TEXT NOT NULL UNIQUE,
            description TEXT,
            creation_datetime TEXT NOT NULL
        )
    """)
    
    # Create the hive_data table to store nodes and edges
    # 'hive_name' is the primary key and must exist in the hives table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS hive_data (
            hive_name TEXT PRIMARY KEY,
            nodes_data TEXT NOT NULL,
            edges_data TEXT NOT NULL,
            last_updated TEXT NOT NULL,
            FOREIGN KEY (hive_name) REFERENCES hives(name) ON DELETE CASCADE
        )
    """)
    
    conn.commit()
    conn.close()

# Ensure database is initialized when the app starts
with app.app_context():
    init_db()

# --- API Endpoints ---

@app.route('/api/addhive', methods=['POST'])
def add_hive():
    """
    API endpoint to add a new hive.
    Requires 'name', optionally accepts 'description'.
    Generates unique ID and creation_datetime automatically.
    """
    data = request.get_json()

    # 1. Input Validation
    hive_name = data.get('name')
    if not hive_name:
        return jsonify({'error': 'Hive name is required.'}), 400

    hive_description = data.get('description', '')

    # 2. Automatic Data Generation (Backend-managed fields)
    hive_id = str(uuid.uuid4())
    # Use ISO format for consistent sorting and representation
    current_time = datetime.now().isoformat()

    conn = get_db_connection()
    cursor = conn.cursor()

    try:
        # 3. Insert into database
        cursor.execute(
            "INSERT INTO hives (id, name, description, creation_datetime) VALUES (?, ?, ?, ?)",
            (hive_id, hive_name, hive_description, current_time)
        )
        conn.commit()

        return jsonify({
            'message': 'Hive added successfully.',
            'hive': {
                'id': hive_id,
                'name': hive_name,
                'description': hive_description,
                'creation_datetime': current_time
            }
        }), 201

    except sqlite3.IntegrityError:
        # Handles the UNIQUE constraint violation for the 'name' field
        conn.rollback()
        return jsonify({'error': f"A hive with the name '{hive_name}' already exists. Hive names must be unique."}), 409
    except Exception as e:
        conn.rollback()
        print(f"Database error: {e}")
        return jsonify({'error': 'An internal error occurred during hive creation.'}), 500


@app.route('/api/hives', methods=['GET'])
def get_hives():
    """
    API endpoint to retrieve all hives, sorted by creation date (newest first).
    """
    conn = get_db_connection()

    # Query all records, ordering by creation_datetime DESC (newest first)
    # The datetime in ISO format (TEXT) sorts correctly as a string
    hives_data = conn.execute(
        "SELECT id, name, description, creation_datetime FROM hives ORDER BY creation_datetime DESC"
    ).fetchall()

    # Convert the list of Row objects (sqlite3.Row) into a list of dictionaries
    hives_list = [dict(hive) for hive in hives_data]

    return jsonify(hives_list), 200


@app.route('/api/hive/<hive_name>/save', methods=['POST'])
def save_hive_data(hive_name):
    """
    API endpoint to save hive nodes and edges data.
    Requires nodes and edges in the request body.
    """
    data = request.get_json()
    
    # 1. Validate input
    if not data:
        return jsonify({'error': 'No data provided.'}), 400
    
    nodes = data.get('nodes', [])
    edges = data.get('edges', [])
    
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        # 2. Check if hive exists in hives table
        hive_exists = cursor.execute(
            "SELECT name FROM hives WHERE name = ?",
            (hive_name,)
        ).fetchone()
        
        if not hive_exists:
            return jsonify({'error': f"Hive '{hive_name}' does not exist in the hives table."}), 404
        
        # 3. Convert nodes and edges to JSON strings
        nodes_json = json.dumps(nodes)
        edges_json = json.dumps(edges)
        current_time = datetime.now().isoformat()
        
        # 4. Insert or update hive data
        cursor.execute("""
            INSERT INTO hive_data (hive_name, nodes_data, edges_data, last_updated)
            VALUES (?, ?, ?, ?)
            ON CONFLICT(hive_name) DO UPDATE SET
                nodes_data = excluded.nodes_data,
                edges_data = excluded.edges_data,
                last_updated = excluded.last_updated
        """, (hive_name, nodes_json, edges_json, current_time))
        
        conn.commit()
        
        return jsonify({
            'message': 'Hive data saved successfully.',
            'hive_name': hive_name,
            'last_updated': current_time,
            'nodes_count': len(nodes),
            'edges_count': len(edges)
        }), 200
        
    except Exception as e:
        conn.rollback()
        print(f"Database error: {e}")
        return jsonify({'error': 'An internal error occurred while saving hive data.'}), 500


@app.route('/api/hive/<hive_name>/load', methods=['GET'])
def load_hive_data(hive_name):
    """
    API endpoint to load hive nodes and edges data.
    Returns the saved data if it exists, otherwise returns None.
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        # 1. Check if hive exists in hives table
        hive_exists = cursor.execute(
            "SELECT name FROM hives WHERE name = ?",
            (hive_name,)
        ).fetchone()
        
        if not hive_exists:
            return jsonify({'error': f"Hive '{hive_name}' does not exist in the hives table."}), 404
        
        # 2. Fetch hive data
        hive_data = cursor.execute(
            "SELECT nodes_data, edges_data, last_updated FROM hive_data WHERE hive_name = ?",
            (hive_name,)
        ).fetchone()
        
        if not hive_data:
            # No saved data exists yet
            return jsonify({
                'exists': False,
                'hive_name': hive_name,
                'message': 'No saved data found for this hive.'
            }), 200
        
        # 3. Parse JSON data
        nodes = json.loads(hive_data['nodes_data'])
        edges = json.loads(hive_data['edges_data'])
        
        return jsonify({
            'exists': True,
            'hive_name': hive_name,
            'nodes': nodes,
            'edges': edges,
            'last_updated': hive_data['last_updated']
        }), 200
        
    except Exception as e:
        print(f"Database error: {e}")
        return jsonify({'error': 'An internal error occurred while loading hive data.'}), 500


# --- Running the Application ---
if __name__ == '__main__':
    print(f"Starting Hive Manager API on http://127.0.0.1:{PORT_NUMBER}")
    print(f"Database file: {os.path.abspath(DATABASE)}")

    # Run the application on the specified non-default port
    app.run(debug=True, port=PORT_NUMBER)
