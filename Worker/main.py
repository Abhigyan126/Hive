import sqlite3
from flask import Flask, request, jsonify, g
from datetime import datetime
import uuid
import os
from flask_cors import CORS # New Import for CORS

# --- Configuration ---
DATABASE = 'hive_data.db'
# Using port 5001 to avoid conflicts with the default 5000
PORT_NUMBER = 5001

# --- Flask App Initialization ---
app = Flask(__name__)
# Initialize CORS to allow all origins ('*') for all routes, fixing the issue.
CORS(app)

# --- Database Connection and Setup ---

def get_db_connection():
    """Establishes a connection to the SQLite database."""
    # 'g' is an object provided by Flask to store and share data during a request
    if 'db' not in g:
        g.db = sqlite3.connect(
            DATABASE,
            detect_types=sqlite3.PARSE_DECLTYPES
        )
        # Allows accessing columns by name instead of index
        g.db.row_factory = sqlite3.Row
    return g.db

@app.teardown_appcontext
def close_connection(exception):
    """Closes the database connection at the end of the request."""
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    """Initializes the database by creating the 'hives' table."""
    # Use a temporary connection just for setup
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()

    # Create the hives table
    # 'id' is generated by Python (UUID)
    # 'name' is mandatory and must be UNIQUE
    # 'creation_datetime' is managed by Python (ISO format)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS hives (
            id TEXT PRIMARY KEY,
            name TEXT NOT NULL UNIQUE,
            description TEXT,
            creation_datetime TEXT NOT NULL
        )
    """)
    conn.commit()
    conn.close()

# Ensure database is initialized when the app starts
with app.app_context():
    init_db()

# --- API Endpoints ---

@app.route('/api/addhive', methods=['POST'])
def add_hive():
    """
    API endpoint to add a new hive.
    Requires 'name', optionally accepts 'description'.
    Generates unique ID and creation_datetime automatically.
    """
    data = request.get_json()

    # 1. Input Validation
    hive_name = data.get('name')
    if not hive_name:
        return jsonify({'error': 'Hive name is required.'}), 400

    hive_description = data.get('description', '')

    # 2. Automatic Data Generation (Backend-managed fields)
    hive_id = str(uuid.uuid4())
    # Use ISO format for consistent sorting and representation
    current_time = datetime.now().isoformat()

    conn = get_db_connection()
    cursor = conn.cursor()

    try:
        # 3. Insert into database
        cursor.execute(
            "INSERT INTO hives (id, name, description, creation_datetime) VALUES (?, ?, ?, ?)",
            (hive_id, hive_name, hive_description, current_time)
        )
        conn.commit()

        return jsonify({
            'message': 'Hive added successfully.',
            'hive': {
                'id': hive_id,
                'name': hive_name,
                'description': hive_description,
                'creation_datetime': current_time
            }
        }), 201

    except sqlite3.IntegrityError:
        # Handles the UNIQUE constraint violation for the 'name' field
        conn.rollback()
        return jsonify({'error': f"A hive with the name '{hive_name}' already exists. Hive names must be unique."}), 409
    except Exception as e:
        conn.rollback()
        print(f"Database error: {e}")
        return jsonify({'error': 'An internal error occurred during hive creation.'}), 500


@app.route('/api/hives', methods=['GET'])
def get_hives():
    """
    API endpoint to retrieve all hives, sorted by creation date (newest first).
    """
    conn = get_db_connection()

    # Query all records, ordering by creation_datetime DESC (newest first)
    # The datetime in ISO format (TEXT) sorts correctly as a string
    hives_data = conn.execute(
        "SELECT id, name, description, creation_datetime FROM hives ORDER BY creation_datetime DESC"
    ).fetchall()

    # Convert the list of Row objects (sqlite3.Row) into a list of dictionaries
    hives_list = [dict(hive) for hive in hives_data]

    return jsonify(hives_list), 200

# --- Running the Application ---
if __name__ == '__main__':
    print(f"Starting Hive Manager API on http://127.0.0.1:{PORT_NUMBER}")
    print(f"Database file: {os.path.abspath(DATABASE)}")

    # Run the application on the specified non-default port
    app.run(debug=True, port=PORT_NUMBER)
